19-10-10
- Takes an API key and a pair
- When run, will import interval_mins candle data in such a way where the next
    candle will come in 1-2 minutes
- On the first new candle, init() will be ran
- On the following new candles, tick() will be ran

19-10-11
On each tick, I need:
(ins)
- Market (exchange/pair)
- Interval
- OHLCV data (candle data)
(portfolios)
- Positions (all owned coins or at least the coins the bot is using.)

On each tick I would like to take care of things like importing the portfolio,
checking for deposits, withdrawals, and trades, and calculating profits. I also
want a built in buy and sell function and pretty much anything else to do with
communicating with binance.

Currently init is ran right at the start, then tick is run 1-2 minutes later and
every interval mins after that.

positions structure:
positions = {
    "asset1": "amt",
    "asset2": "amt",
    ...
}

I don't have the total account size. I also don't have the prices for each asset.
I do have the price of the pair though, from ins. So I can calculate the size
of the trading account in terms of the base coin.

If I wanted to monitor all coins it would be hard to determine dw or other trade
status.. If I only monitor the trading account it will be about the same as on
ct.

However, I could use my ability to get info about dws and other trades... And I
could use that to monitor all of the coins.

Anyways, for now I'll just monitor the trading account like on CT. This will be
easier.

10-13
If I keep calling vars like exchange, pair, candles etc inside of functions (tick)
which I didn't pass those vars into, it causes bugs.

If I try to update the value of one of these vars, it creates a temporary var
inside the function so that the outside var is not changed.

If I try to print a var, then change its value, I'll get a bug because the
var I'm trying to print, the temporary var, hasn't been created yet. Even though
the outer var is perfectly defined.

To avoid these issues, I need to pass the var into the function. Then I can
update its value permanently and the var is always defined.

However, I have a lot of vars which I need to pass in. So I think instead of
passing them all individually, I'll create an Instance class which stores all
this info, and then I can just pass the class instance into the function.

***

Test: Can I change a value in tick and then still see the new value on the next
tick? Can I print a var and then change its value afterwords?

***

Also, I want the candles to be an attribute of the Instance class. Because each
trading instance will be using its own candle data.

As for the portfolio..

I could track the whole account and all dws/trades but then how do I run multiple
instances? I would have to stop the portfolio tracker and all of the running
bots every time I want to add a new one.

If I just import portfolio data for the asset and base and save it as a part of
the Instance class then I can run different bots in different terminals, but I
have to program the logic to see dws/trades.

Well actually maybe I can still import dws/trades information.

10-14
The Instance class stores everything:
- Exchange
- Asset, base, pair
- Interval
- Candles
- Portfolio

It pings every 2 seconds where it checks for a new raw_candle and/or candle.
On each new candle it ticks.

10-22
After messing around with dws/trades (dwts) direct imports.. It seems feasible.

I can get only the dws that happened since the end of the most recent candle.
With trades, I'll have to get the most recent 500 and eliminate irrelevant ones.

Well actually, I don't have to get the 500 most recent, I can lower that number.
Is there a case when I would want a large number of imported trades?
Well, maybe the user was messing around with something, and in the course of 2
hours traded 100 times.. Unlikely, but possible.

If the user trades more times than the program imports, there will be a
discrepancy between the actual assetchange and basechange vs the assetchange and
basechange predicted by the imports.

I shall calculate the predicted assetchange and basechange once I imports dwts
and then compare it with the actual assetchange and basechange and see what I
discover.
